# Specification-Driven Development (SDD) 在 Claude Code 的最佳实践

> 综合 Anthropic 官方文档 + 社区工具 + Codex 多轮协作整理

---

## 📖 如何阅读本文档

| 你的情况 | 推荐阅读 |
|---------|---------|
| 完全不了解 SDD | TL;DR → 核心理念 → 标准工作流 → 快速启动 |
| 想快速上手 | 附录 A 速查表 → 快速启动 → 实战案例 |
| 想深入实践 | 完整阅读，重点关注高阶实践和 Codex 洞察 |
| 想团队推广 | 成熟度评估 → FAQ → 30 天入门计划 |

---

## ⚡ TL;DR（3 分钟速览）

### 什么是 SDD？
**先写规范，后写代码**。规范是唯一事实源，充当 AI 编程的"灯塔"。

### 核心工作流
```
Requirements → Design → Tasks → Implementation
    需求    →  设计  →  任务  →     实现
```

### 五个必做
1. **规范编号化** - 每条需求 `US-001`，每条验收 `AC-001`
2. **验收可执行** - `Given-When-Then` 可直接生成测试
3. **提示语引用规范** - `"依据 spec.md §3.1 实现..."`
4. **双向 Diff** - 规范↔实现 互相检查
5. **规范同步 PR** - 规范和代码同仓同提交

### 一句话总结
> 给 Claude 深度上下文，它才能给你深度输出。

---

## 📑 目录

- [如何阅读本文档](#-如何阅读本文档)
- [TL;DR 速览](#-tldr3-分钟速览)

1. [核心理念](#一核心理念)
2. [标准工作流](#二标准工作流四阶段)
3. [规范文件结构](#三规范文件结构)
4. [Claude Code 原生功能](#四claude-code-原生功能支持)
5. [核心实践要点](#五核心实践要点)
6. [完整实战案例](#六完整实战案例)
7. [高阶实践](#七高阶实践)
8. [工具生态](#八工具生态)
9. [SDD 成熟度评估](#九sdd-成熟度评估)
10. [常见问题 FAQ](#十常见问题-faq)
11. [实用小技巧](#十一实用小技巧)
12. [避坑指南](#十二避坑指南)
13. [快速启动](#十三快速启动)
14. [SDD vs 其他方法论](#十四sdd-vs-其他方法论)
15. [参考资源](#十五参考资源)
- [附录 A：一页纸速查表](#附录-a一页纸速查表)
- [附录 B：提示语模板库](#附录-b提示语模板库)
- [附录 C：Codex 核心洞察](#附录-ccodex-核心洞察)
- [附录 D：30 天入门计划](#附录-d30-天入门计划)
- [附录 E：项目检查清单](#附录-esdd-项目检查清单可打印)
- [附录 F：术语表](#附录-f术语表)

---

## 一、核心理念

**规范是唯一事实源** —— 先规范，后代码。

```
详细规范 → 充当单一事实来源 → 像灯塔一样指导整个开发过程
```

**为什么 SDD 对 AI 编程特别重要？**
- AI 需要深度上下文，模糊的一句话提示只会得到模糊的结果
- 规范文件是"长期资产"，生命周期超过代码本身
- 规范可用来在未来重新生成整个代码库

---

## 二、标准工作流（四阶段）

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Requirements│───▶│   Design    │───▶│    Tasks    │───▶│Implementation│
│    需求      │    │    设计     │    │    任务     │    │     实现     │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
```

| 阶段 | 核心产出 | Claude 职责 | 完成标志 |
|------|---------|------------|---------|
| **Requirements** | 用户故事、验收准则、边界条件 | 链式追问直到边界清晰 | 所有用例/错误场景/非功能指标齐备 |
| **Design** | 架构图、数据模型、接口契约 | 评估技术可行性、识别风险 | 技术方案确定、依赖明确 |
| **Tasks** | 可执行任务列表 | 分解为最小可验证增量 | 每个任务可独立验证 |
| **Implementation** | 代码 + 测试 | 边实现边与规范双向 diff | 测试通过、规范覆盖 100% |

**关键原则**: 每阶段必须完成并批准后才能进入下一阶段。

---

## 三、规范文件结构

### 推荐模板

```markdown
# [项目名] Specification v1.0

## §1 背景与范围
- 项目背景
- 解决的问题
- 目标用户和价值主张
- 不在范围内的内容（明确边界）

## §2 用户故事
- US-001: 作为 [角色]，我想要 [功能]，以便 [价值]
- US-002: ...
（每条编号，便于追溯）

## §3 功能规格
### §3.1 [功能模块名]
- 输入定义
- 输出定义
- 处理逻辑
- 异常处理

## §4 验收准则（可执行）
- AC-001: Given [前提], When [操作], Then [结果]
- AC-002: ...
（直接可转为测试用例）

## §5 非功能需求
- 性能要求
- 安全需求
- 可用性要求

## §6 依赖与约束
| 依赖项 | 版本 | 用途 | 兼容策略 |
|--------|------|------|----------|

## §7 风险假设清单
| ID | 假设内容 | 验证方式 | 状态 |
|----|---------|---------|------|
| R-001 | ... | ... | 待验证 |

## §8 决策记录
| 日期 | 决策 | 替代方案 | 理由 |
|------|------|---------|------|
```

### 关键要点

1. **编号一切** - 每条需求、验收准则、风险都有唯一 ID，便于 Claude 引用追溯
2. **可执行优先** - 验收准则写成 Given-When-Then，可直接生成测试
3. **边界明确** - "在范围内"和"不在范围内"同样重要

---

## 四、Claude Code 原生功能支持

### 4.1 Plan Mode（规划模式）

```bash
# 启动规划模式（只读分析，不修改代码）
cc -p "分析当前代码库，为 [功能] 制定规范"
```

**适用场景**:
- 规范阶段的代码库分析
- 评估技术可行性
- 设计审查

### 4.2 Extended Thinking（深度思考）

在提示中嵌入触发词：
```
请"think very hard"分析这个复杂需求...
请"ultrathink"评估这个架构决策的利弊...
```

**适用场景**:
- 复杂规范推理
- 架构决策
- 风险分析

### 4.3 Subagents（子代理）

```
用子代理验证这个设计方案的可行性
用子代理并行探索 3 个不同的技术方案
```

**适用场景**:
- 并行探索多个方案
- 验证细节问题
- 保留主上下文

### 4.4 Context 管理

```bash
/clear    # 阶段切换时清理上下文
/compact  # 压缩但保留关键信息
```

**最佳实践**: 每完成一个阶段后 `/compact`，避免上下文溢出。

---

## 五、核心实践要点

### 5.1 先规范后代码

```
❌ 错误流程: 需求 → 直接写代码 → 发现问题 → 返工
✅ 正确流程: 需求 → 完整规范 → 生成测试 → 实现代码
```

**执行要点**:
- 用 Claude 链式追问：用例 → 错误场景 → 边界条件 → 非功能指标
- 未写完规范绝不写代码

### 5.2 提示语模板化

```markdown
# 不好的提示
实现用户登录功能

# 好的提示
依据 spec.md §3.1 用户认证模块：
- 实现 US-001 描述的登录功能
- 满足 AC-001 到 AC-005 的验收准则
- 遵循 §5 中的安全要求
```

**效果**: 显式引用规范章节，减少 Claude 臆测，保持上下文对齐。

### 5.3 审查循环短而频

每完成一个模块，执行双向 diff：

```
┌─────────────────────────────────────────┐
│            双向 Diff 检查               │
├─────────────────────────────────────────┤
│ 实现 → 规范: 是否覆盖全部需求？          │
│ 规范 → 实现: 是否有多余/过时的规范？      │
└─────────────────────────────────────────┘
```

**提示模板**:
```
对比 spec.md §3.1 和当前实现：
1. 列出规范中已实现的条目
2. 列出规范中未实现的条目
3. 列出实现中超出规范的部分
```

### 5.4 可执行规范优先

规范阶段就约定测试表格、API schema、数据约束：

```markdown
## 验收准则 AC-001
Given: 用户已注册且密码正确
When: 用户提交登录表单
Then: 返回 200 + JWT token

## 对应测试（由 Claude 生成）
def test_login_success():
    user = create_user("test@example.com", "password123")
    response = client.post("/login", {"email": "test@example.com", "password": "password123"})
    assert response.status_code == 200
    assert "token" in response.json()
```

### 5.5 版本同步管理

```
规范和代码同仓 + 同步 PR
     │
     ▼
┌─────────────────────────────────────────┐
│ Claude 评审顺序:                         │
│ 1. 先评审规范 diff                       │
│ 2. 再评审实现 diff                       │
│ 3. 规范变更 → 提醒更新实现和测试          │
└─────────────────────────────────────────┘
```

---

## 六、完整实战案例

### 场景：为电商应用添加"优惠券"功能

#### Phase 1: Requirements（需求阶段）

**提示语**:
```
我需要为电商应用添加优惠券功能。请帮我梳理完整的需求规范，包括：
1. 所有可能的用户故事
2. 边界条件和异常场景
3. 非功能需求（性能、安全）
用链式追问的方式，确保没有遗漏。
```

**Claude 输出**（精简版）:
```markdown
## §2 用户故事
- US-001: 作为用户，我想要在结算时输入优惠码，以便获得折扣
- US-002: 作为用户，我想要看到优惠券的有效期和使用条件
- US-003: 作为运营，我想要创建/编辑/禁用优惠券
- US-004: 作为运营，我想要设置优惠券的使用限制（次数、金额门槛）

## §4 验收准则
- AC-001: Given 有效优惠码, When 用户输入, Then 显示折扣金额
- AC-002: Given 已过期优惠码, When 用户输入, Then 显示"优惠码已过期"
- AC-003: Given 订单金额 < 门槛, When 使用优惠码, Then 显示"未满足使用条件"
- AC-004: Given 优惠码已达使用上限, When 用户输入, Then 显示"优惠码已被领完"

## §7 风险假设
- R-001: 高并发场景下优惠码可能超发（需分布式锁）
- R-002: 用户可能通过多账号刷券（需设备指纹/手机号限制）
```

#### Phase 2: Design（设计阶段）

**提示语**:
```
基于上述需求规范，请设计：
1. 数据模型（优惠券表结构）
2. 核心 API 接口
3. 并发控制方案（解决 R-001）
请给出至少 2 个备选方案并对比利弊。
```

#### Phase 3: Tasks（任务阶段）

**提示语**:
```
将设计拆解为可独立验证的任务列表，每个任务：
1. 明确输入输出
2. 对应的验收准则 ID
3. 预估复杂度（S/M/L）
```

**Claude 输出**:
```markdown
| Task | 描述 | 对应 AC | 复杂度 |
|------|------|--------|--------|
| T-001 | 创建 coupon 表和模型 | - | S |
| T-002 | 实现优惠码校验 API | AC-001~004 | M |
| T-003 | 实现分布式锁防超发 | R-001 | L |
| T-004 | 实现后台优惠券管理 CRUD | US-003 | M |
| T-005 | 编写集成测试 | AC-001~004 | M |
```

#### Phase 4: Implementation（实现阶段）

**提示语**:
```
依据 spec.md §3.1 优惠券校验模块：
- 实现 T-002 描述的优惠码校验 API
- 满足 AC-001 到 AC-004 的验收准则
- 先写测试，再实现代码
```

**迭代检查**:
```
对比 spec.md §3.1 和当前实现：
1. 列出已实现的 AC 条目
2. 列出未实现的 AC 条目
3. 发现的新边界条件（更新到规范）
```

---

## 七、高阶实践

### 7.1 度量追踪矩阵

让 Claude 生成并维护：

| 需求 ID | 测试覆盖 | 监控上线 | 负责人 | 状态 |
|---------|---------|---------|--------|------|
| US-001  | ✓       | ✓       | @dev1  | Done |
| US-002  | ✓       | ○       | @dev2  | WIP  |
| US-003  | ○       | ○       | -      | TODO |

**空白即风险**，逐格打钩确认。

### 7.2 决策记录（ADR）

```markdown
## ADR-001: 选择 JWT 而非 Session 认证

**日期**: 2026-01-02
**状态**: 已采纳

**背景**: 需要支持多端登录和无状态扩展

**决策**: 使用 JWT + Refresh Token 方案

**替代方案**:
1. Session + Redis（被否决：增加运维复杂度）
2. OAuth2（被否决：MVP 阶段过度设计）

**后果**:
- 正面：无状态、易扩展
- 负面：Token 撤销需额外机制
```

### 7.3 风险假设清单

| ID | 假设 | 风险等级 | 验证方式 | 当前状态 |
|----|------|---------|---------|---------|
| R-001 | 第三方 API 响应 < 200ms | 高 | 压测验证 | 待验证 |
| R-002 | 日活 < 10000 | 中 | 监控观察 | 已验证 |

**每次评审逐条确认状态**，避免风险跨阶段遗忘。

### 7.4 知识沉淀

每轮 Claude 交互暴露的假设、冲突、决策记录成"哨兵清单"：

```markdown
## 哨兵清单 v1.2

### 常见遗漏
- [ ] 忘记定义错误码规范
- [ ] 忘记考虑并发场景
- [ ] 忘记定义日志格式

### 常见偏差
- Claude 倾向于过度设计，需明确约束 MVP 范围
- Claude 生成的测试缺少边界条件，需补充

### 最佳提示片段
- "请只实现 MVP，不要添加额外功能"
- "列出所有可能的错误场景和对应错误码"
```

### 7.5 可观测性前置

**在规范阶段就定义运维三件套**：

```markdown
## §9 可观测性规范

### 日志规范
| 事件 | 级别 | 格式 | 示例 |
|------|------|------|------|
| 优惠码校验成功 | INFO | `coupon_applied: {code}, discount: {amount}` | ... |
| 优惠码校验失败 | WARN | `coupon_rejected: {code}, reason: {reason}` | ... |

### 关键指标
| 指标 | 类型 | 阈值 | 报警方式 |
|------|------|------|---------|
| coupon_apply_success_rate | Gauge | < 95% | PagerDuty |
| coupon_apply_latency_p99 | Histogram | > 200ms | Slack |

### 报警规则
- 优惠码使用失败率 > 5%：触发 P2 报警
- 优惠码 API 延迟 > 500ms：触发 P3 报警
```

**价值**: 上线后能快速映射异常到具体规范条目。

### 7.6 依赖合约化

让 Claude 在规范中维护依赖基线表：

| 上游服务 | 版本 | 接口 | 约束 | 兼容策略 |
|---------|------|------|------|---------|
| 用户服务 | v2.3 | GET /users/{id} | 响应 < 100ms | 降级到缓存 |
| 支付服务 | v1.8 | POST /payments | 幂等性要求 | 重试 3 次 |
| 短信服务 | v3.0 | POST /sms | 限流 100/s | 队列缓冲 |

**执行规则**: 依赖更新时，先更新此表并触发规范评审。

### 7.7 多模型交叉验证

对关键规范片段引入第二个模型验证：

```
请用 Codex 对以下规范进行交叉验证：
1. 是否有描述模糊的条目？
2. 是否有潜在冲突？
3. 是否有遗漏的边界条件？

汇总两个模型的差异点，标记需人工裁决的冲突。
```

**适用场景**: 核心业务逻辑、安全相关规范、复杂状态机。

### 7.8 渐进式交付

在规范中定义"最小可验证增量"：

```markdown
## §10 里程碑定义

### M1: 基础能力（Week 1）
- [ ] 优惠码校验 API
- [ ] 基础错误处理
- 验证方式: 单元测试 + 手动测试

### M2: 完整功能（Week 2）
- [ ] 后台管理界面
- [ ] 使用限制逻辑
- 验证方式: 集成测试 + QA 测试

### M3: 生产就绪（Week 3）
- [ ] 监控报警
- [ ] 文档完善
- 验证方式: 压测 + 灰度发布
```

**原则**: 每个里程碑独立可验证，规范状态随里程碑同步更新。

---

## 八、工具生态

| 工具 | 特点 | 适用场景 | 链接 |
|------|------|---------|------|
| **cc-sdd** | Kiro 风格命令，强制四阶段工作流 | 团队标准化 | [GitHub](https://github.com/gotalab/cc-sdd) |
| **claude-code-spec-workflow** | 自动化 SDD + Bug Fix 工作流 | 个人效率 | [GitHub](https://github.com/Pimzino/claude-code-spec-workflow) |
| **GitHub Spec-Kit** | GitHub 官方 SDD 工具包 | 开源项目 | [GitHub](https://github.com/github/spec-kit) |

---

## 九、SDD 成熟度评估

### 自检清单

| 等级 | 特征 | 达标标准 |
|------|------|---------|
| **L1 初级** | 有规范意识 | 开发前写需求文档 |
| **L2 基础** | 规范结构化 | 使用编号、验收准则可执行 |
| **L3 进阶** | 规范驱动开发 | 先写测试、双向 diff、规范同步 PR |
| **L4 精通** | 闭环迭代 | 度量追踪、知识沉淀、多模型验证 |
| **L5 卓越** | 组织级实践 | 规范模板标准化、自动化工作流、团队共识机制 |

### 快速诊断

回答以下问题，每个 Yes 得 1 分：

1. [ ] 是否有标准的规范模板？
2. [ ] 验收准则是否可直接生成测试？
3. [ ] 规范和代码是否在同一个 PR 中提交？
4. [ ] 是否有风险假设清单并定期评审？
5. [ ] 是否维护决策记录（ADR）？
6. [ ] 是否有需求→测试→监控的追踪矩阵？
7. [ ] 是否有"哨兵清单"沉淀常见问题？
8. [ ] 规范阶段是否定义了可观测性要求？
9. [ ] 是否使用多模型交叉验证关键规范？
10. [ ] 上线后是否将缺陷映射回规范条目？

**评分标准**:
- 0-2: L1 初级
- 3-4: L2 基础
- 5-6: L3 进阶
- 7-8: L4 精通
- 9-10: L5 卓越

---

## 十、常见问题 FAQ

### Q1: SDD 会不会让开发变慢？

**A**: 前期投入更多，但总体更快。

```
传统模式: 需求(1) → 编码(3) → Debug(5) → 返工(3) = 12 单位时间
SDD 模式: 规范(3) → 编码(3) → Debug(1) → 返工(0) = 7 单位时间
```

规范越清晰，返工越少。

### Q2: 小项目也需要 SDD 吗？

**A**: 视复杂度而定。

| 项目类型 | 建议 |
|---------|------|
| 一次性脚本 | 不需要 |
| 简单 CRUD | 精简版规范（只需用户故事+验收准则） |
| 核心业务逻辑 | 完整 SDD |
| 多人协作项目 | 强烈推荐 |

### Q3: 规范写多详细合适？

**A**: 以"Claude 能无歧义理解"为标准。

**过于简略**:
```
实现用户登录功能
```

**过于冗长**:
```
（3 页详细的实现细节...）
```

**恰到好处**:
```
§3.1 用户登录
- 输入: email(string, 必填), password(string, 必填)
- 输出: {token: string, expires_at: timestamp}
- AC-001: Given 有效凭证, When POST /login, Then 返回 200 + token
- AC-002: Given 无效密码, When POST /login, Then 返回 401 + 错误信息
```

### Q4: 规范变更怎么处理？

**A**: 规范变更是正常的，关键是同步。

```
1. 先更新规范文件
2. 标记影响的 AC 条目
3. 让 Claude 识别受影响的代码和测试
4. 更新实现 + 测试
5. 同一个 PR 提交
```

### Q5: 如何说服团队采用 SDD？

**A**: 从小处开始，用数据说话。

1. 选一个中等复杂度的新功能试点
2. 完整执行 SDD 流程
3. 记录返工次数、Bug 数量、开发时间
4. 与历史项目对比
5. 分享经验和收益

### Q6: 何时使用 SDD？决策流程

```
开始
  │
  ▼
是否使用 AI 辅助开发？ ──No──▶ 传统方法即可
  │
  Yes
  ▼
项目复杂度如何？
  │
  ├─ 简单（<3天）──▶ 精简版：只需用户故事 + 验收准则
  │
  ├─ 中等（1-2周）──▶ 标准版：完整四阶段 SDD
  │
  └─ 复杂（>2周）──▶ 增强版：SDD + 高阶实践（多模型验证、度量矩阵等）
```

**快速判断**:
- ✅ 用 SDD：核心业务逻辑、多人协作、需要长期维护
- ❌ 不用 SDD：一次性脚本、快速原型、探索性实验

---

## 十一、实用小技巧

### 🚀 效率提升
- **批量生成测试**: `"根据 AC-001 到 AC-010 批量生成测试用例"`
- **快速规范模板**: 创建 `/sdd-init` 自定义命令自动生成规范骨架
- **规范版本对比**: `git diff HEAD~1 spec.md` 快速查看变更

### 🔧 调试技巧
- **规范追溯**: 出 bug 时先用 `grep "AC-XXX" spec.md` 找对应规范
- **上下文保护**: 复杂任务前 `/compact`，避免上下文溢出
- **回滚安全**: 规范变更失败时，代码回滚后规范也要同步回滚

### 💡 最佳实践
- **晨会同步**: 每天同步"规范 vs 实现"进度，及时发现偏差
- **规范评审**: 重要规范发布前让同事（或另一个 AI）评审
- **持续优化**: 每月回顾"哨兵清单"，更新规范模板

---

## 十二、避坑指南

| 反模式 | 问题 | 正确做法 |
|--------|------|---------|
| 规范一次性文档 | 很快过时，失去指导意义 | 规范随代码同步演进，同仓同 PR |
| Markdown 过度冗长 | 信噪比低，Claude 难以聚焦 | 精简结构化，编号引用，可执行优先 |
| 口头通过 | 无据可查，容易遗忘 | 证据化评审（截图/日志/指标链接） |
| 单一方案锁定 | 缺乏备选，遇阻时无退路 | 至少准备 2 个备选策略 |
| 模型输出直接用 | 累积偏差，质量下降 | 对比历史偏差，设置校准提醒 |
| 需求变更无记录 | 团队对承诺状态失忆 | 维护变更日志，记录理由和影响 |

---

## 十三、快速启动

```bash
# 1. 创建规范文件
touch spec.md  # 或在 CLAUDE.md 中添加规范区块

# 2. 用 Plan Mode 启动规范分析
cc -p "分析以下需求，生成完整的规范文档：[需求描述]"

# 3. 生成可执行测试
cc "根据 spec.md 的验收准则 AC-001 到 AC-010，生成测试用例"

# 4. 分模块实现
cc "依据 spec.md §3.1 实现用户认证模块，满足 AC-001 到 AC-003"

# 5. 双向 Diff 检查
cc "对比 spec.md §3.1 和当前实现，列出差异"

# 6. 更新规范
cc "根据实现过程中的发现，更新 spec.md 的风险假设清单"
```

---

## 十四、SDD vs 其他方法论

| 维度 | SDD | TDD | BDD | 传统瀑布 |
|------|-----|-----|-----|---------|
| **核心驱动** | 规范文档 | 测试用例 | 行为场景 | 需求文档 |
| **先写什么** | 规范 → 测试 → 代码 | 测试 → 代码 | 场景 → 测试 → 代码 | 文档 → 代码 → 测试 |
| **AI 友好度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |
| **适用场景** | AI 辅助开发 | 算法/逻辑密集 | 业务规则复杂 | 合规/审计要求 |
| **学习曲线** | 中 | 低 | 中 | 低 |
| **与 Claude Code 配合** | 最佳 | 良好 | 良好 | 一般 |

**关键洞察**: SDD 可以看作是 TDD + BDD 的超集，特别为 AI 编程优化。

---

## 十五、参考资源

- [Claude Code: Best practices for agentic coding](https://www.anthropic.com/engineering/claude-code-best-practices) - Anthropic 官方
- [Spec-Driven Development with Claude Code](https://www.arsturn.com/blog/spec-driven-development-with-claude-code) - 社区指南
- [GitHub Spec-Kit](https://github.com/github/spec-kit) - GitHub 官方工具
- [cc-sdd](https://github.com/gotalab/cc-sdd) - 社区工作流工具
- [claude-code-spec-workflow](https://github.com/Pimzino/claude-code-spec-workflow) - 自动化工作流

---

## 附录 A：一页纸速查表

### 🎯 核心原则
```
规范 → 测试 → 代码 → 验证 → 更新规范
```

### 📋 规范必备要素
- [ ] 用户故事（编号）
- [ ] 验收准则（Given-When-Then）
- [ ] 边界条件
- [ ] 风险假设
- [ ] 依赖清单

### 🔧 Claude Code 命令速查
```bash
cc -p "..."           # Plan Mode 只读分析
cc "think hard ..."   # 深度思考
/clear                # 清理上下文
/compact              # 压缩上下文
```

### 📝 提示语模板
```
依据 spec.md §[章节] [模块名]：
- 实现 US-[ID] 描述的功能
- 满足 AC-[ID] 到 AC-[ID] 的验收准则
- [额外约束]
```

### ✅ 每模块完成检查
1. 双向 Diff（规范↔实现）
2. 测试覆盖
3. 更新度量矩阵
4. 更新风险状态

### ⚠️ 常见陷阱
- 不要跳过 Requirements 阶段
- 不要让规范变成一次性文档
- 不要接受口头通过
- 不要忽略风险假设评审

---

## 附录 B：提示语模板库

### 需求阶段
```
请帮我梳理 [功能] 的完整需求规范：
1. 列出所有可能的用户故事
2. 识别边界条件和异常场景
3. 定义非功能需求（性能、安全）
4. 列出高风险假设

用链式追问的方式，确保没有遗漏。
```

### 设计阶段
```
基于 spec.md 的需求规范，请设计：
1. 数据模型（表结构/Schema）
2. 核心 API 接口定义
3. 关键算法/流程

请给出至少 2 个备选方案并对比利弊。
```

### 任务拆解
```
将 spec.md §[章节] 拆解为可独立验证的任务：
- 每个任务明确输入输出
- 标注对应的验收准则 ID
- 预估复杂度（S/M/L）
```

### 实现阶段
```
依据 spec.md §[章节] [模块名]：
- 实现 [任务描述]
- 满足 AC-[ID] 到 AC-[ID]
- 先写测试，再实现代码
- 请只实现 MVP，不要添加额外功能
```

### 双向 Diff
```
对比 spec.md §[章节] 和当前实现：
1. 列出规范中已实现的条目
2. 列出规范中未实现的条目
3. 列出实现中超出规范的部分
4. 发现的新边界条件（需更新规范）
```

### 规范评审
```
请评审以下规范的质量：
1. 是否有描述模糊的条目？
2. 是否有潜在冲突？
3. 是否有遗漏的边界条件？
4. 验收准则是否可执行？
```

---

## 附录 C：Codex 核心洞察

> 以下是 Codex 在 19 轮协作讨论中提出的核心观点精选

### 🎯 关于规范本身
- **规范是长期资产** - 生命周期超过代码本身，可用于未来重新生成整个代码库
- **编号是追溯的基础** - 每条需求、验收、风险都编号，便于 Claude 引用回溯
- **可执行 > 描述性** - 规范应直接可转化为测试，而非仅仅描述

### 🔄 关于流程
- **审查循环短而频** - 每个模块完成后双向 diff，而非最后统一检查
- **规范和代码同步 PR** - 规范变更即触发实现和测试的同步更新
- **证据化评审** - 每条通过的规范需附上证据（截图/日志/指标），杜绝口头通过

### 🛡️ 关于风险
- **高风险假设清单** - 技术债、外部依赖、变更窗口等，每次评审逐条确认
- **约束冲突模拟** - 规范阶段列出主要约束并推演冲突，提前避开高风险路径
- **依赖合约化** - 上游接口→版本→约束→兼容策略表，依赖更新先更新表

### 📊 关于度量
- **需求→测试→监控链路表** - 发布后用真实指标回填，量化规范有效性
- **规范驱动回顾** - 迭代结束对比"规范承诺 vs 实际交付"，量化差距来源
- **执行健康仪表** - 规范完成度、实现覆盖度、测试通过率、监控上线率

### 🧠 关于 AI 协作
- **提示语模板化** - 显式引用规范章节（如"依据 §2 用户故事 #3"），减少臆测
- **多模型交叉验证** - 关键规范引入第二个模型验证，发现模糊和盲区
- **模型校准** - 对比历史偏差清单，新任务前设置校准提醒

### 💡 关于持续改进
- **知识沉淀** - 每轮交互暴露的假设、冲突、决策记录成"哨兵清单"
- **提示基准测试** - 定期 A/B 测试常见规范提示，依据结果更新模板
- **可复用资产标记** - 规范中标记可复用组件/策略，存入共享目录

---

## 附录 D：30 天入门计划

### Week 1: 基础建立
| 天 | 任务 | 产出 |
|----|------|------|
| 1-2 | 阅读本文档，理解 SDD 核心概念 | 理解四阶段工作流 |
| 3-4 | 创建第一个 spec.md，尝试编号规范 | 一份简单的规范文档 |
| 5 | 用 Plan Mode 分析一个小需求 | 熟悉 `cc -p` 命令 |
| 6-7 | 写第一个 Given-When-Then 验收准则 | 可执行的验收准则 |

### Week 2: 实践应用
| 天 | 任务 | 产出 |
|----|------|------|
| 8-9 | 选一个小功能，完整走四阶段流程 | 第一个 SDD 项目 |
| 10-11 | 实践双向 Diff 检查 | 掌握规范↔实现对比 |
| 12-13 | 尝试提示语模板化 | 建立个人提示语库 |
| 14 | 回顾总结，记录遇到的问题 | Week 2 复盘笔记 |

### Week 3: 进阶技能
| 天 | 任务 | 产出 |
|----|------|------|
| 15-16 | 创建度量追踪矩阵 | 第一个追踪矩阵 |
| 17-18 | 维护风险假设清单 | 风险管理意识 |
| 19-20 | 尝试决策记录（ADR） | 第一份 ADR |
| 21 | 建立个人"哨兵清单" | 经验沉淀开始 |

### Week 4: 团队推广
| 天 | 任务 | 产出 |
|----|------|------|
| 22-23 | 选一个团队项目试点 SDD | 团队级规范文档 |
| 24-25 | 引入同步 PR 机制 | 规范版本控制 |
| 26-27 | 分享 SDD 经验，收集反馈 | 团队反馈 |
| 28-30 | 调整流程，建立团队标准 | 团队 SDD 指南 v1.0 |

### 成功标志
- [ ] 能独立完成四阶段 SDD 流程
- [ ] 建立了个人提示语模板库
- [ ] 有至少 3 个项目使用 SDD
- [ ] 团队开始采用 SDD 实践

---

## 附录 E：SDD 项目检查清单（可打印）

### 📋 Requirements 阶段
- [ ] 所有用户故事已编号（US-XXX）
- [ ] 边界条件已识别
- [ ] 异常场景已列出
- [ ] 非功能需求已定义（性能/安全/可用性）
- [ ] 风险假设已记录

### 📐 Design 阶段
- [ ] 数据模型已设计
- [ ] API 接口已定义
- [ ] 技术方案已确定
- [ ] 至少有 2 个备选方案评估
- [ ] 依赖清单已更新

### ✂️ Tasks 阶段
- [ ] 任务已拆解为最小可验证增量
- [ ] 每个任务对应明确的 AC
- [ ] 任务复杂度已评估（S/M/L）
- [ ] 里程碑已定义

### 🔨 Implementation 阶段（每个模块）
- [ ] 测试先写
- [ ] 代码实现完成
- [ ] 双向 Diff 检查通过
- [ ] 度量矩阵已更新
- [ ] 风险状态已确认

### 🚀 发布前
- [ ] 所有 AC 测试通过
- [ ] 规范和代码同步 PR
- [ ] 监控/告警已上线
- [ ] 规范文档已更新
- [ ] 决策记录已归档

---

## 附录 F：术语表

| 术语 | 英文 | 定义 |
|------|------|------|
| **SDD** | Specification-Driven Development | 规范驱动开发，先写规范后写代码的方法论 |
| **US** | User Story | 用户故事，描述用户需求的格式 |
| **AC** | Acceptance Criteria | 验收准则，用于验证功能是否完成 |
| **ADR** | Architecture Decision Record | 架构决策记录，记录重要的技术决策 |
| **双向 Diff** | Bidirectional Diff | 规范与实现的双向对比检查 |
| **哨兵清单** | Sentinel Checklist | 从经验中提炼的常见问题清单 |
| **度量矩阵** | Metrics Matrix | 需求→测试→监控→负责人的追踪表 |
| **Plan Mode** | - | Claude Code 的只读规划模式（`cc -p`） |
| **Extended Thinking** | - | 深度思考模式，通过特定触发词激活 |
| **Subagent** | - | 子代理，用于并行探索或验证 |

---

---

*本文档由 Claude + Codex 多模型协作整理*
*Version 1.0 | 2026-01-02*
*Codex 协作轮次: 19 轮 | 死磕优化迭代: 16 轮*
*总行数: ~990 行 | 阅读时间: ~30 分钟*
