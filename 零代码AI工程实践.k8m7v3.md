# 🎯 零代码 AI 工程实践 英语段落翻译

本文共 **35 个语义单元**，将全部翻译。

---

(1)

**{Over the past five months, our team has been running an experiment: [building and shipping an internal beta of a software product with 0 lines of manually-written code].} {The product has internal daily users and external alpha testers.} {It ships, deploys, breaks, and gets fixed.} {What's different is [that every line of code—application logic, tests, CI configuration, documentation, observability, and internal tooling—has been written by Codex].}**

过去五个月，我们团队一直在进行一项实验：构建并发布一款没有任何一行手写代码的内部测试产品。这款产品有内部日活用户和外部内测用户，它会上线、部署、崩溃、被修复。与众不同的是，每一行代码——应用逻辑、测试、**CI** 配置、文档、可观测性和内部工具——全都由 **Codex** 编写。

解析：
* **internal beta** /ˈɪntənl ˈbeɪtə/：内部公测版（beta 是软件测试阶段）
* **alpha tester**：内测用户（alpha 比 beta 更早期的测试阶段）
* **observability** /əbˌzɜːvəˈbɪlɪti/：可观测性（监控系统运行状态的能力）
* **CI (Continuous Integration)**：持续集成（自动化测试/构建流程）

---

(2)

**{We estimate [that we built this in about 1/10th the time (it would have taken to write the code by hand)].} {Humans steer.} {Agents execute.}**

我们估计，完成这个项目的时间大约是手写代码所需时间的十分之一。人类负责引导方向，**Agent** 负责执行。

解析：
* **steer** /stɪə/：动词，掌舵、引导方向 🔥（本义：驾驶/操控方向）
* **execute** /ˈeksɪkjuːt/：动词，执行（不只是"处决"，更常用于"执行任务"）

---

(3)

**{We intentionally chose this constraint [so we would build what was necessary to increase engineering velocity by orders of magnitude].} {We had weeks [to ship what ended up being a million lines of code].}**

我们有意选择了这个约束，目的是倒逼自己打造出能将工程效率提升数个数量级的必要工具。我们只有几周时间来交付最终超过百万行的代码。

解析：
* **constraint** /kənˈstreɪnt/：名词，约束、限制
* **intentionally** /ɪnˈtenʃənəli/：副词，有意地、刻意地
* **orders of magnitude** 🔥：数量级（表示 10 倍、100 倍等量级的增长）
* **velocity** /vəˈlɒsɪti/：速度（工程中常指开发速度/吞吐速率）

---

(4)

**{To do that, we needed [to understand what changes when a software engineering team's primary job is no longer to write code, but to design environments, specify intent, and build feedback loops (that allow Codex agents to do reliable work)].} {This post is about [what we learned by building a brand new product with a team of agents]—[what broke, what compounded, and how to maximize our one truly scarce resource: human time and attention].}**

为此，我们需要理解：当一个软件工程团队的核心职责不再是写代码，而是设计环境、表达意图、构建反馈循环——让 **Codex Agent** 完成可靠工作时，会发生什么变化。这篇文章讲述的是我们用 **Agent** 团队构建全新产品的过程中学到的东西——哪些出了问题，哪些产生了复利，以及如何最大化我们唯一真正稀缺的资源：人类的时间和注意力。

解析：
* **specify intent**：表达/明确意图（告诉系统"要做什么"而非"怎么做"）
* **feedback loop** 🔥：反馈循环（系统根据结果自动调整的机制）
* **compound** /ˈkɒmpaʊnd/：动词，积累复利、使问题不断加剧 🔥
* **scarce** /skeəs/：形容词，稀缺的、匮乏的

---

(5)

**{The first commit to an empty repository landed in late August 2025.} {The initial scaffold—repository structure, CI configuration, formatting rules, package manager setup, and application framework—was generated by Codex CLI [using GPT‑5, guided by a small set of existing templates].} {Even the initial AGENTS.md file [that directs agents how to work in the repository] was itself written by Codex.}**

第一个提交落地于 2025 年 8 月底。最初的脚手架——仓库结构、**CI** 配置、格式规则、包管理器设置和应用框架——由 **Codex CLI** 使用 **GPT-5** 生成，以少量已有模板为参考。就连指导 **Agent** 如何在仓库中工作的初始 **AGENTS.md** 文件，也是由 **Codex** 自己写的。

解析：
* **scaffold** /ˈskæfəʊld/：脚手架（项目初始化框架，帮助快速搭起基础结构）
* **package manager**：包管理器（如 npm、pip，管理代码依赖）
* **application framework**：应用框架（如 React、Django 等基础开发框架）

---

(6)

**{There was no pre-existing human-written code [to anchor the system].} {From the beginning, the repository was shaped by the agent.} {Five months later, the repository contains on the order of a million lines of code across application logic, infrastructure, tooling, documentation, and internal developer utilities.}**

从一开始，系统中就没有任何已有的人类代码作为基础，仓库完全由 **Agent** 塑造。五个月后，仓库中的代码量达到约百万行，涵盖应用逻辑、基础设施、工具、文档和内部开发者工具。

解析：
* **anchor** /ˈæŋkər/：动词，作为基础/锚点 🔥（本义：抛锚固定，引申为"稳住/支撑"）
* **on the order of**：大约、数量级在……左右
* **utilities** /juːˈtɪlɪtɪz/：工具程序（utility software，帮助开发者的小工具）

---

(7)

**{Over that period, roughly 1,500 pull requests have been opened and merged with a small team of [just three engineers driving Codex].} {This translates to an average throughput of 3.5 PRs per engineer per day, and surprisingly the throughput has increased [as the team has grown to now seven engineers].} {Importantly, this wasn't output for output's sake: the product has been used by hundreds of users internally, including daily internal power users.} {Throughout the development process, humans never directly contributed any code.} {This became a core philosophy for the team: no manually-written code.}**

在此期间，仅凭三名工程师驱动 **Codex**，就合并了约 1500 个 **PR**，平均每名工程师每天 3.5 个。令人惊讶的是，随着团队扩大到七名工程师，吞吐量反而还在增长。重要的是，这不是为了刷数字——产品已被数百名内部用户使用，包括每天都在用的核心用户。整个开发过程中，没有人直接贡献过一行代码，"零手写代码"成了团队的核心哲学。

解析：
* **throughput** /ˈθruːpaʊt/：名词，吞吐量、产出率 🔥（单位时间内完成的工作量）
* **output for output's sake**：为了产出而产出（没有实际价值的刷数据）
* **power user**：深度用户、高频使用的核心用户

---

(8)

**{The lack of [hands-on human coding] introduced a different kind of engineering work, focused on systems, scaffolding, and leverage.} {Early progress was slower than we expected, not because Codex was incapable, but because the environment was underspecified.} {The agent lacked the tools, abstractions, and internal structure [required to make progress toward high-level goals].} {The primary job of our engineering team became enabling the agents to do useful work.}**

缺少了人类亲手敲代码，工程工作的性质发生了根本转变，焦点变成了系统搭建、脚手架和杠杆效应。早期进展比预期慢，不是因为 **Codex** 能力不足，而是因为环境描述得不够具体。**Agent** 缺少完成高层目标所需的工具、抽象层和内部结构。我们团队的首要任务变成了：让 **Agent** 能够做有用的工作。

解析：
* **hands-on** /ˌhændz ˈɒn/：亲身参与的、实操的 🔥（"上手干"的感觉）
* **underspecified** /ˌʌndəˈspesɪfaɪd/：描述不充分的、规格不足的
* **leverage** /ˈliːvərɪdʒ/：杠杆效应（用小投入撬动大产出）🔥
* **abstraction** /æbˈstrækʃn/：抽象层（对复杂细节的封装，简化使用）

---

(9)

**{In practice, this meant working depth-first: [breaking down larger goals into smaller building blocks (design, code, review, test, etc)], [prompting the agent to construct those blocks], and [using them to unlock more complex tasks].} {When something failed, the fix was almost never "try harder."}**

在实践中，这意味着要采用深度优先的工作方式：将更大的目标分解为更小的构建块（设计、代码、评审、测试等），让 **Agent** 构建这些模块，再用它们来解锁更复杂的任务。当某件事失败时，解决方案几乎从来不是"再努力一点"。

解析：
* **depth-first** /depθ fɜːst/：深度优先（先深入再扩展的搜索/工作策略）
* **building blocks** 🔥：构建块、基本模块（像搭积木一样的基础单元）
* **unlock** /ʌnˈlɒk/：解锁、使成为可能（常见于游戏和工程语境）

---

(10)

**{Because the only way to make progress was to get Codex to do the work, human engineers always stepped into the task and asked: "what capability is missing, and how do we make it both legible and enforceable for the agent?"} {Humans interact with the system almost entirely through prompts: [an engineer describes a task, runs the agent, and allows it to open a pull request].}**

因为让 **Codex** 完成工作是进步的唯一途径，人类工程师总是要回到任务本身，追问："缺少什么能力？如何让这个能力对 **Agent** 来说既清晰可读又可执行？"人类与系统的交互几乎完全通过 **prompt** 进行：工程师描述一个任务，运行 **Agent**，让它去开 **PR**。

解析：
* **legible** /ˈledʒɪbl/：可读的、清晰易懂的（通常指文字，这里引申为"Agent 可理解的"）
* **enforceable** /ɪnˈfɔːsəbl/：可执行的、可强制遵守的
* **prompt** /prɒmpt/：提示词（给 AI 的指令文本）

---

(11)

**{To drive a PR to completion, we instruct Codex [to review its own changes locally, request additional specific agent reviews both locally and in the cloud, respond to any human or agent given feedback, and iterate in a loop until all agent reviewers are satisfied] (effectively this is a Ralph Wiggum Loop).} {Codex uses our standard development tools directly (gh, local scripts, and repository-embedded skills) [to gather context without humans copying and pasting into the CLI].}**

为了推动 **PR** 完成，我们让 **Codex** 在本地自查代码改动，在本地和云端请求额外的 **Agent** 评审，回应任何人类或 **Agent** 的反馈，反复循环直到所有评审 **Agent** 都满意——这实际上就是一个 **Ralph Wiggum Loop**（自我循环直到通过）。**Codex** 直接使用标准开发工具（**gh**、本地脚本和仓库内置技能）获取上下文，不需要人类复制粘贴到命令行。

解析：
* **drive a PR to completion** 🔥：推动 **PR** 完成合并（drive 在这里是"推进"的意思）
* **iterate** /ˈɪtəreɪt/：动词，迭代、反复循环
* **repository-embedded skills**：内嵌在仓库中的技能/工具

---

(12)

**{Humans may review pull requests, but aren't required to.} {Over time, we've pushed almost all review effort towards being handled agent-to-agent.} {As code throughput increased, our bottleneck became human QA capacity.} {Because the fixed constraint has been human time and attention, we've worked [to add more capabilities to the agent by making things like the application UI, logs, and app metrics themselves directly legible to Codex].}**

人类可以审查 **PR**，但不是必须的。随着时间推移，我们已将几乎所有评审工作都推向了 **Agent** 与 **Agent** 之间自主处理。随着代码产出速度提升，我们的瓶颈变成了人工 **QA** 的产能。由于固定的约束是人类的时间和注意力，我们努力让应用的 **UI**、日志和指标对 **Codex** 直接"可读"，从而赋予 **Agent** 更多能力。

解析：
* **agent-to-agent** 🔥：**Agent** 对 **Agent**，不经过人类中转
* **bottleneck** /ˈbɒtlnek/：名词，瓶颈（限制整体速度的环节）🔥
* **QA (Quality Assurance)**：质量保证/测试

---

(13)

**{For example, we made the app bootable per git worktree, [so Codex could launch and drive one instance per change].} {We also wired the Chrome DevTools Protocol into the agent runtime and created skills [for working with DOM snapshots, screenshots, and navigation].} {This enabled Codex [to reproduce bugs, validate fixes, and reason about UI behavior directly].}**

例如，我们让应用可以按 **git worktree** 独立启动，让 **Codex** 能为每个变更启动一个独立实例。我们还将 **Chrome DevTools Protocol** 接入 **Agent** 运行时，创建了处理 **DOM** 快照、截图和页面导航的技能。这让 **Codex** 能够直接复现 **bug**、验证修复，并对 **UI** 行为进行推理。

解析：
* **bootable** /ˈbuːtəbl/：可启动的
* **worktree** /ˈwɜːktriː/：工作树（**git** 的隔离工作空间特性，允许同时 checkout 多个分支）
* **reproduce bugs** 🔥：复现 **bug**（让问题重新出现以便调试）
* **DOM (Document Object Model)**：文档对象模型（网页结构的编程接口）

---

(14)

**{We did the same for observability tooling.} {Logs, metrics, and traces are exposed to Codex via a local observability stack (that's ephemeral for any given worktree).} {Codex works on a fully isolated version of that app—including its logs and metrics, [which get torn down once that task is complete].} {Agents can query logs with LogQL and metrics with PromQL.}**

我们对可观测性工具也做了同样的处理。日志、指标和链路追踪通过一个临时的本地可观测性堆栈暴露给 **Codex**，每个 **worktree** 独立一套。**Codex** 在完全隔离的应用副本上工作——包括其日志和指标，任务完成后即销毁。**Agent** 可以用 **LogQL** 查询日志，用 **PromQL** 查询指标。

解析：
* **observability stack**：可观测性技术栈（收集日志/指标/追踪的工具集合）
* **ephemeral** /ɪˈfemərəl/：形容词，短暂的、临时性的 🔥
* **torn down**：拆除、销毁（基础设施被清理掉）
* **traces**：链路追踪（记录一个请求在分布式系统中完整路径的数据）

---

(15)

**{With this context available, prompts like "ensure service startup completes in under 800ms" or "no span in these four critical user journeys exceeds two seconds" become tractable.} {We regularly see single Codex runs work on a single task for upwards of six hours (often while the humans are sleeping).}**

有了这些上下文，"确保服务启动在 800 毫秒内完成"或"这四个关键用户旅程中没有 **span** 超过两秒"这样的 **prompt** 就变得可操作了。我们经常看到一次 **Codex** 运行在单个任务上工作六个多小时——往往是在人类睡觉的时候。

解析：
* **tractable** /ˈtræktəbl/：可处理的、可操作的 🔥（反义词 intractable：棘手的、难以解决的）
* **upwards of** 🔥：超过、多达（"upwards of six hours" = 六个多小时）
* **span** /spæn/：在可观测性中指一段操作的追踪单元（如一次数据库查询）

---

(16)

**{Context management is one of the biggest challenges [in making agents effective at large and complex tasks].} {One of the earliest lessons we learned was simple: give Codex a map, not a 1,000-page instruction manual.} {We tried the "one big AGENTS.md" approach.} {It failed in predictable ways.}**

上下文管理是让 **Agent** 高效处理大型复杂任务的最大挑战之一。我们最早学到的一个简单道理是：给 **Codex** 一张地图，而不是一本一千页的操作手册。我们尝试过"一个大 **AGENTS.md**"的方案，结果以可预见的方式失败了。

解析：
* **context management**：上下文管理（控制 AI 在一次对话中接收信息的范围和优先级）
* **instruction manual**：操作手册、说明书
* **in predictable ways**：以可预见的方式（表示"失败原因不难猜到"）

---

(17)

**{Context is a scarce resource.} {A giant instruction file crowds out the task, the code, and the relevant docs—so the agent either misses key constraints or starts [optimizing for the wrong ones].} {Too much guidance becomes non-guidance.} {When everything is "important," nothing is.} {Agents end up [pattern-matching locally] instead of [navigating intentionally].}**

上下文是稀缺资源。一个巨型指令文件会挤占任务、代码和相关文档的空间，**Agent** 要么错过关键约束，要么优化错了方向。过多的指导反而等于没有指导——当所有事都"重要"时，就没有什么是真正重要的，**Agent** 最终只会在局部做模式匹配，而不是有目的地导航整个仓库。

解析：
* **crowd out** 🔥：挤占、排挤（本意人群涌入将别人挤走，引申为占用宝贵资源）
* **pattern-matching locally**：局部模式匹配（只看眼前相似的代码来判断，不考虑全局）
* **navigating intentionally**：有意图地导航（清楚知道去哪找什么信息）

---

(18)

**{It rots instantly.} {A monolithic manual turns into a graveyard of stale rules.} {Agents can't tell [what's still true], humans stop maintaining it, and the file quietly becomes an attractive nuisance.} {It's hard to verify.} {A single blob doesn't lend itself to mechanical checks (coverage, freshness, ownership, cross-links), so drift is inevitable.}**

它会迅速腐烂。单体手册会变成一堆过时规则的坟场，**Agent** 分不清哪些还有效，人类也不再维护，文件悄悄变成一个让人头疼的"陷阱"。它也很难验证——单一大文件无法做覆盖率、新鲜度、归属和交叉链接等机械检查，偏差不可避免。

解析：
* **monolithic** /ˌmɒnəˈlɪθɪk/：形容词，单体的、庞大且不可拆分的 🔥（软件架构中常见词）
* **graveyard** /ˈɡreɪvjɑːd/：坟场（比喻废弃内容的集合）
* **attractive nuisance** /njuːsns/：吸引人却有害的东西（法律术语，引申为"看起来有用实则有害"）
* **drift** /drɪft/：漂移、偏差（系统状态逐渐偏离预期）

---

(19)

**{So instead of [treating AGENTS.md as the encyclopedia], we treat it as the table of contents.} {The repository's knowledge base lives in a structured docs/ directory [treated as the system of record].} {A short AGENTS.md (roughly 100 lines) is injected into context and serves primarily as a map, with pointers to deeper sources of truth elsewhere.}**

因此，我们不再把 **AGENTS.md** 当百科全书，而是把它当作目录。仓库的知识库存放在结构化的 **docs/** 目录中，作为唯一可信来源。一个简短的 **AGENTS.md**（约 100 行）被注入上下文，主要作为地图使用，并指向其他更深层的知识源。

解析：
* **system of record** 🔥：唯一可信来源（所有人以此为准的权威数据源）
* **inject into context**：注入上下文（将内容提供给 AI 模型读取）
* **pointer** /ˈpɔɪntər/：指针（这里指文档中指向其他资源的链接/引用）

---

(20)

**{Design documentation is catalogued and indexed, including verification status and a set of core beliefs [that define agent-first operating principles].} {Architecture documentation provides a top-level map of domains and package layering.} {A quality document grades each product domain and architectural layer, tracking gaps over time.}**

设计文档被分类索引，包含验证状态和一套定义 **Agent** 优先运营原则的核心信念。架构文档提供领域和包分层的顶层地图。质量文档对每个产品领域和架构层进行评分，随时间追踪薄弱环节。

解析：
* **catalogue** /ˈkætəlɒɡ/：动词，将……分类编目 🔥
* **domain** /dəˈmeɪn/：领域（业务模块的划分单位，如"支付领域""用户领域"）
* **package layering**：包分层（代码按功能分层组织的架构方式）
* **gap** /ɡæp/：差距、缺口（这里指质量薄弱、需要改进的地方）

---

(21)

**{Plans are treated as first-class artifacts.} {Ephemeral lightweight plans are used for small changes, while complex work is captured in execution plans [with progress and decision logs (that are checked into the repository)].} {Active plans, completed plans, and known technical debt are all versioned and co-located, [allowing agents to operate without relying on external context].}**

计划被视为一等公民。小改动用临时的轻量计划，复杂工作则记录在执行计划中，包含进度和决策日志并提交入仓库。活跃计划、已完成计划和已知技术债都有版本控制且放在一起，让 **Agent** 无需依赖外部上下文就能操作。

解析：
* **first-class artifact** 🔥：一等公民（与代码同等重要的产出物）
* **ephemeral** /ɪˈfemərəl/：短暂的、临时性的
* **co-located** /ˌkəʊləʊˈkeɪtɪd/：并置的、存放在同一位置
* **checked into the repository**：提交进仓库（用 git 提交并保存）

---

(22)

**{This enables progressive disclosure: [agents start with a small, stable entry point and are taught where to look next, rather than being overwhelmed up front].} {We enforce this mechanically.} {Dedicated linters and CI jobs validate [that the knowledge base is up to date, cross-linked, and structured correctly].} {A recurring "doc-gardening" agent scans for stale or obsolete documentation [that does not reflect the real code behavior] and opens fix-up pull requests.}**

这实现了渐进式披露：**Agent** 从一个小而稳定的入口开始，被引导去找下一步需要的信息，而不是一开始就被信息淹没。我们通过机械手段强制执行这一原则——专用 **linter** 和 **CI** 任务验证知识库是否最新、有交叉链接、结构正确。一个定期运行的"文档园艺" **Agent** 会扫描不反映真实代码行为的过时或废弃文档，并自动开 **PR** 修复。

解析：
* **progressive disclosure** 🔥：渐进式披露（按需展示信息，避免信息过载）
* **mechanically** /mɪˈkænɪkli/：机械地、自动化地 🔥（不依赖人工判断，靠工具自动执行）
* **stale** /steɪl/：过时的（比如面包放久了变硬，引申为"内容不新鲜"）
* **obsolete** /ˌɒbsəˈliːt/：废弃的、已淘汰的

---

(23)

**{As the codebase evolved, Codex's framework for design decisions needed to evolve, too.} {Because the repository is entirely agent-generated, it's optimized first for Codex's legibility.} {In the same way [teams aim to improve navigability of their code for new engineering hires], our human engineers' goal was [making it possible for an agent to reason about the full business domain directly from the repository itself].}**

随着代码库不断演进，**Codex** 的设计决策框架也需要随之演进。由于仓库完全由 **Agent** 生成，它首先针对 **Codex** 的可读性进行优化。就像团队会为新入职工程师提升代码可导航性一样，我们人类工程师的目标是：让 **Agent** 能够直接从仓库本身推理出完整的业务领域。

解析：
* **navigability** /ˌnævɪɡəˈbɪlɪti/：可导航性（代码结构是否容易找到和理解）
* **reason about** 🔥：对……进行推理、分析（常见于 AI/哲学语境）

---

(24)

**{From the agent's point of view, anything [it can't access in-context while running] effectively doesn't exist.} {Knowledge [that lives in Google Docs, chat threads, or people's heads] are not accessible to the system.} {Repository-local, versioned artifacts (e.g., code, markdown, schemas, executable plans) are all it can see.}**

从 **Agent** 的视角来看，它在运行时无法在上下文中访问到的东西，实际上等于不存在。存在于 **Google Docs**、聊天记录或人们脑海中的知识，系统都无法获取。仓库本地的、有版本的产物（代码、**markdown**、**schema**、可执行计划等）才是它能看到的全部。

解析：
* **in-context** /ɪn ˈkɒntekst/：在上下文中（AI 当次运行能读到的内容范围内）
* **versioned artifacts** 🔥：有版本的产物（可追溯历史记录的文件，存在 git 中）
* **schema** /ˈskiːmə/：数据结构定义、模式（描述数据长什么样的规范）

---

(25)

**{We learned [that we needed to push more and more context into the repo over time].} {That Slack discussion [that aligned the team on an architectural pattern]? [If it isn't discoverable to the agent], it's illegible in the same way [it would be unknown to a new hire joining three months later].} {Giving Codex more context means [organizing and exposing the right information (so the agent can reason over it)], rather than [overwhelming it with ad-hoc instructions].}**

我们意识到，需要随时间不断将更多上下文推送到仓库里。那次让团队就架构模式达成一致的 **Slack** 讨论？如果 **Agent** 发现不了，它就像三个月后入职的新员工一样——完全不知道这段历史。给 **Codex** 更多上下文，意味着组织和暴露合适的信息让 **Agent** 推理，而不是用临时拼凑的指令淹没它。

解析：
* **aligned the team on**：让团队在某事上达成一致 🔥
* **discoverable** /dɪˈskʌvərəbl/：可被发现的（Agent 能通过搜索找到的）
* **ad-hoc** /ˌæd ˈhɒk/：临时性的、专门的 🔥（不系统、随用随扔，如"临时加的指令"）

---

(26)

**{This framing clarified many tradeoffs.} {We favored dependencies and abstractions [that could be fully internalized and reasoned about in-repo].} {Technologies often described as "boring" tend to be easier for agents to model due to composability, api stability, and representation in the training set.} {In some cases, it was cheaper [to have the agent reimplement subsets of functionality] than [to work around opaque upstream behavior from public libraries].}**

这个思路厘清了很多取舍。我们倾向于选择能在仓库内被完全内化和推理的依赖和抽象。那些通常被称为"无聊"的技术，由于可组合性强、**API** 稳定、在训练集中有充分表示，往往更容易被 **Agent** 建模。在某些情况下，让 **Agent** 重新实现部分功能，比绕过第三方库中不透明的上游行为代价更低。

解析：
* **tradeoff** /ˈtreɪdɒf/：权衡取舍（得到一样东西就要放弃另一样）
* **internalized** /ɪnˈtɜːnəlaɪzd/：被内化的（彻底理解并融入自身知识体系）
* **composability** /kəmˌpəʊzəˈbɪlɪti/：可组合性（组件可自由组合的特性）
* **opaque** /əʊˈpeɪk/：不透明的、晦涩难懂的 🔥（看不进去内部的感觉）

---

(27)

**{For example, rather than pulling in a generic p-limit-style package, we implemented our own map-with-concurrency helper: it's tightly integrated with our OpenTelemetry instrumentation, has 100% test coverage, and behaves exactly [the way our runtime expects].} {Pulling more of the system into a form [the agent can inspect, validate, and modify directly] increases leverage—not just for Codex, but for other agents (e.g. Aardvark) [that are working on the codebase as well].}**

例如，我们没有引入通用的 **p-limit** 风格的包，而是自己实现了一个 map-with-concurrency 工具函数：它与我们的 **OpenTelemetry** 埋点深度集成，测试覆盖率 100%，行为完全符合运行时预期。将系统更多部分转化为 **Agent** 可直接检查、验证和修改的形式，能提升杠杆效应——不仅对 **Codex**，对同样在代码库中工作的其他 **Agent**（如 **Aardvark**）也是如此。

解析：
* **pulling in a package**：引入一个第三方包（依赖）
* **concurrency** /kənˈkɜːrənsi/：并发（同时处理多个任务）
* **instrumentation** /ˌɪnstrəmenˈteɪʃn/：埋点、监控插桩（在代码中插入追踪代码）
* **OpenTelemetry**：开源可观测性框架（收集 traces、metrics、logs 的标准）

---

(28)

**{Documentation alone doesn't keep a fully agent-generated codebase coherent.} {By enforcing invariants, not micromanaging implementations, we let agents ship fast without undermining the foundation.} {For example, we require Codex [to parse data shapes at the boundary], but are not prescriptive on how that happens (the model seems to like Zod, but we didn't specify that specific library).}**

仅靠文档无法维持完全由 **Agent** 生成的代码库的一致性。通过强制执行不变量而不是微管理具体实现，我们让 **Agent** 能快速交付而不破坏基础。例如，我们要求 **Codex** 在边界处解析数据结构，但不规定怎么做——模型似乎喜欢用 **Zod**，但我们没有指定这个具体的库。

解析：
* **coherent** /kəʊˈhɪərənt/：形容词，一致的、连贯的 🔥
* **invariants** /ɪnˈveəriənts/：不变量（始终为真的约束条件，无论代码怎么变）
* **micromanage** /ˌmaɪkrəʊˈmænɪdʒ/：微管理（干预每一个细节）🔥
* **prescriptive** /prɪˈskrɪptɪv/：规定性的（告诉你必须怎么做，而非可以怎么做）

---

(29)

**{Agents are most effective in environments [with strict boundaries and predictable structure], so we built the application around a rigid architectural model.} {Each business domain is divided into a fixed set of layers, with strictly validated dependency directions and a limited set of permissible edges.} {These constraints are enforced mechanically via custom linters (Codex-generated, of course!) and structural tests.}**

**Agent** 在有严格边界和可预测结构的环境中效率最高，因此我们围绕一个严格的架构模型来构建应用。每个业务领域被划分为固定的层级集合，依赖方向严格验证，允许的依赖边也有限制。这些约束通过自定义 **linter**（当然是 **Codex** 生成的！）和结构测试机械地强制执行。

解析：
* **rigid** /ˈrɪdʒɪd/：严格的、刚性的（不允许随意变通）
* **permissible edges** /pəˈmɪsɪbl/：允许的边（图论概念，指架构中合法的依赖关系）
* **structural tests**：结构性测试（验证代码组织结构是否符合规范的测试）

---

(30)

**{Within each business domain (e.g. App Settings), code can only depend "forward" through a fixed set of layers (Types → Config → Repo → Service → Runtime → UI).} {Cross-cutting concerns (auth, connectors, telemetry, feature flags) enter through a single explicit interface: Providers.} {Anything else is disallowed and enforced mechanically.} {This is the kind of architecture [you usually postpone until you have hundreds of engineers].} {With coding agents, it's an early prerequisite: the constraints are what allows speed without decay or architectural drift.}**

在每个业务领域内（如应用设置），代码只能沿固定层级"向前"依赖（Types → Config → Repo → Service → Runtime → UI）。横切关注点（认证、连接器、遥测、功能开关）通过唯一的显式接口进入：**Providers**。其他所有依赖方式都被禁止并机械执行。这种架构通常要等到有数百名工程师时才会去建立，但有了代码 **Agent**，它反而是早期的前提条件——这些约束正是让速度与质量并行、不发生腐蚀和架构漂移的保障。

解析：
* **cross-cutting concerns** 🔥：横切关注点（贯穿多个模块的通用功能，如日志、认证）
* **telemetry** /tɪˈlemətri/：遥测（远程收集系统状态数据）
* **prerequisite** /ˌpriːˈrekwɪzɪt/：前提条件、先决条件 🔥
* **decay** /dɪˈkeɪ/：腐烂、衰退（这里指代码质量随时间下降）

---

(31)

**{In practice, we enforce these rules with custom linters and structural tests, plus a small set of "taste invariants."} {For example, we statically enforce structured logging, naming conventions for schemas and types, file size limits, and platform-specific reliability requirements with custom lints.} {Because the lints are custom, we write the error messages [to inject remediation instructions into agent context].} {In a human-first workflow, these rules might feel pedantic or constraining.} {With agents, they become multipliers: once encoded, they apply everywhere at once.}**

在实践中，我们用自定义 **linter**、结构测试，以及一小套"品味不变量"来执行这些规则。例如，我们用自定义 **lint** 静态执行结构化日志、**schema** 和类型命名规范、文件大小限制以及平台特定的可靠性要求。由于 **linter** 是自定义的，我们在错误信息里直接注入修复指引，让 **Agent** 收到报错时就知道怎么改。在以人类为主的工作流中，这些规则可能显得迂腐，但对 **Agent** 来说，它们成了乘数——一旦编码进去，立刻在所有地方生效。

解析：
* **statically enforce**：静态执行（在代码运行前，通过分析工具强制检查）
* **pedantic** /pɪˈdæntɪk/：形容词，过于迂腐的、学究气的 🔥
* **multiplier** /ˈmʌltɪplaɪər/：乘数、放大器 🔥（一次投入，到处生效）
* **remediation** /rɪˌmiːdiˈeɪʃn/：修复、补救措施

---

(32)

**{At the same time, we're explicit about [where constraints matter and where they do not].} {This resembles [leading a large engineering platform organization]: enforce boundaries centrally, allow autonomy locally.} {The resulting code does not always match human stylistic preferences, and that's okay.} {As long as the output is correct, maintainable, and legible to future agent runs, it meets the bar.} {Human taste is fed back into the system continuously.}**

同时，我们对哪里需要约束、哪里不需要保持明确。这很像管理一个大型工程平台组织：集中强制边界，局部允许自由。最终生成的代码不总是符合人类的风格偏好，但没关系——只要输出正确、可维护、对未来 **Agent** 运行可读，就达标了。人类的"品味"会持续反馈进系统。

解析：
* **autonomy** /ɔːˈtɒnəmi/：名词，自主权、自治
* **stylistic preferences**：风格偏好（代码写法的个人习惯偏好）
* **meet the bar** 🔥：达标（bar 指门槛/标准，这是很常用的表达）

---

(33)

**{Review comments, refactoring pull requests, and user-facing bugs are captured as documentation updates or encoded directly into tooling.} {When documentation falls short, we promote the rule into code.} {As Codex's throughput increased, many conventional engineering norms became counterproductive.} {The repository operates with minimal blocking merge gates.} {Pull requests are short-lived.} {Test flakes are often addressed with follow-up runs rather than blocking progress indefinitely.} {In a system [where agent throughput far exceeds human attention], corrections are cheap, and waiting is expensive.}**

评审意见、重构 **PR** 和面向用户的 **bug** 都被记录为文档更新或直接编码进工具；当文档不够用时，就把规则提升为代码。随着 **Codex** 吞吐量提升，很多传统工程规范反而变成了阻碍。仓库以最少的合并阻断门控运行，**PR** 生命周期很短，测试不稳定问题通常靠后续重跑解决，而不是无限期阻塞进度——在 **Agent** 吞吐量远超人类注意力的系统中，纠错成本很低，等待才是代价高昂的事。

解析：
* **counterproductive** /ˌkaʊntəprəˈdʌktɪv/：适得其反的 🔥
* **merge gates**：合并门控（合并代码前必须通过的检查条件）
* **test flakes** /fleɪks/：不稳定的测试（偶发失败的测试，不是因为代码有 bug）
* **indefinitely** /ɪnˈdefɪnɪtli/：无限期地、无限地

---

(34)

**{When we say the codebase is generated by Codex agents, we mean everything in the codebase.} {Agents produce: Product code and tests, CI configuration and release tooling, Internal developer tools, Documentation and design history, Evaluation harnesses, Review comments and responses, Scripts that manage the repository itself, Production dashboard definition files.} {Humans always remain in the loop, but work at a different layer of abstraction than we used to.} {We prioritize work, translate user feedback into acceptance criteria, and validate outcomes.} {When the agent struggles, we treat it as a signal: identify what is missing—tools, guardrails, documentation—and feed it back into the repository, always by having Codex itself write the fix.}**

当我们说代码库由 **Codex Agent** 生成时，意思是代码库里的一切：产品代码和测试、**CI** 配置和发布工具、内部开发者工具、文档和设计历史、评估工具框架、评审意见和回复、管理仓库自身的脚本、生产看板定义文件……人类始终处于循环之中，但工作在不同的抽象层——排优先级、将用户反馈转化为验收标准、验证结果。当 **Agent** 遇到困难，我们将其视为信号：识别缺少什么（工具、护栏、文档），然后反馈进仓库，始终让 **Codex** 自己来写修复。

解析：
* **evaluation harnesses**：评估工具框架（系统性测试 AI 输出质量的工具集）
* **acceptance criteria** 🔥：验收标准（判断功能是否完成的条件，PO/PM 常用词）
* **guardrails** /ˈɡɑːdreɪlz/：护栏（防止系统越界或出错的约束机制）🔥

---

(35)

**{As more of the development loop was encoded directly into the system—testing, validation, review, feedback handling, and recovery—the repository recently crossed a meaningful threshold [where Codex can end-to-end drive a new feature].} {Given a single prompt, the agent can now: Validate the current state of the codebase; Reproduce a reported bug; Record a video demonstrating the failure; Implement a fix; Validate the fix by driving the application; Record a second video demonstrating the resolution; Open a pull request; Respond to agent and human feedback; Detect and remediate build failures; Escalate to a human only when judgment is required; Merge the change.} {This behavior depends heavily on [the specific structure and tooling of this repository] and should not be assumed to generalize without similar investment—at least, not yet.}**

随着测试、验证、评审、反馈处理和恢复等开发循环环节被直接编码进系统，仓库最近跨过了一个重要门槛：**Codex** 可以端到端地驱动一个新特性。只需一个 **prompt**，**Agent** 现在就能：验证代码库当前状态、复现已报告的 **bug**、录制展示问题的视频、实现修复、驱动应用验证修复、录制展示解决的第二个视频、开 **PR**、回应 **Agent** 和人类的反馈、检测并修复构建失败、仅在需要判断时才上报给人类，最终合并变更。这种能力高度依赖该仓库的特定结构和工具，不应假设没有类似投入就能复制——至少目前还不行。

解析：
* **threshold** /ˈθreʃhəʊld/：门槛、临界点 🔥（跨过这个点，能力发生质变）
* **end-to-end** 🔥：端到端（从头到尾的完整流程，无需中间人介入）
* **remediate** /rɪˈmiːdieɪt/：动词，修复、补救
* **escalate** /ˈeskəleɪt/：升级处理、上报 🔥（问题超出当前层级，需往上报）

---

> *(36–结尾部分)*

**{Full agent autonomy also introduces novel problems.} {Codex replicates patterns [that already exist in the repository]—even uneven or suboptimal ones.} {Over time, this inevitably leads to drift.} {Initially, humans addressed this manually.} {Our team used to spend every Friday (20% of the week) cleaning up "AI slop."} {Unsurprisingly, that didn't scale.}**

完全的 **Agent** 自主性也带来了新问题：**Codex** 会复制仓库中已有的模式——即便是不均匀或次优的模式，久而久之这必然导致漂移。起初，人类手动解决这个问题，团队每个星期五（占一周 20% 的时间）都在清理"**AI** 糟粕"。不出所料，这根本无法规模化。

解析：
* **novel** /ˈnɒvl/：形容词，新颖的、前所未有的
* **suboptimal** /ˌsʌbˈɒptɪml/：次优的、不够理想的 🔥
* **slop** /slɒp/：劣质内容、一塌糊涂（俚语，表示质量低劣的产出）
* **scale** /skeɪl/：动词，规模化 🔥（"doesn't scale" = 无法随规模增长维持效果）

---

> *(37)*

**{Instead, we started [encoding what we call "golden principles" directly into the repository] and built a recurring cleanup process.} {These principles are opinionated, mechanical rules [that keep the codebase legible and consistent for future agent runs].} {For example: (1) we prefer shared utility packages over hand-rolled helpers to keep invariants centralized, and (2) we don't probe data "YOLO-style"—[we validate boundaries or rely on typed SDKs (so the agent can't accidentally build on guessed shapes)].}**

于是我们开始将"黄金原则"直接编码进仓库，并建立了定期清理流程。这些原则是带有明确立场的机械规则，让代码库对未来的 **Agent** 运行保持可读和一致。例如：(1) 我们偏好共享工具包而非手写辅助函数，保持不变量集中；(2) 我们不以"**YOLO**"方式探测数据——而是在边界处验证，或依赖类型化的 **SDK**，避免 **Agent** 基于猜测的数据结构进行开发。

解析：
* **opinionated** /əˈpɪnjəneɪtɪd/：有明确立场的 🔥（框架/工具对"正确做法"有自己的主张）
* **hand-rolled** /hænd rəʊld/：手写的、自制的（不依赖现成库，自己从头写）
* **YOLO-style**："你只活一次"风格（随意尝试、不加验证）🔥
* **probe** /prəʊb/：探测（随意访问数据，不做类型校验）

---

> *(38)*

**{On a regular cadence, we have a set of background Codex tasks [that scan for deviations, update quality grades, and open targeted refactoring pull requests].} {Most of these can be reviewed in under a minute and automerged.} {This functions like garbage collection.} {Technical debt is like a high-interest loan: it's almost always better [to pay it down continuously in small increments] than [to let it compound and tackle it in painful bursts].} {Human taste is captured once, then enforced continuously on every line of code.}**

我们定期运行一批后台 **Codex** 任务，扫描偏差、更新质量评分并开出有针对性的重构 **PR**，大多数不到一分钟就能审查完并自动合并。这就像垃圾回收机制——技术债就像高息贷款，几乎总是持续以小增量还清，比让它复利积累、最终痛苦地集中偿还要好得多。人类的"品味"被捕获一次，之后在每一行代码上持续强制执行。

解析：
* **cadence** /ˈkeɪdns/：节奏、周期性频率 🔥（"on a regular cadence" = 定期、有节奏地）
* **deviations** /ˌdiːviˈeɪʃnz/：偏差、偏离
* **garbage collection** /ˈɡɑːbɪdʒ/：垃圾回收（程序自动释放无用内存的机制）
* **increments** /ˈɪŋkrɪmənts/：增量、小幅增加 🔥

---

> *(39)*

**{What we don't yet know is [how architectural coherence evolves over years in a fully agent-generated system].} {We're still learning [where human judgment adds the most leverage and how to encode that judgment so it compounds].} {What's become clear: building software still demands discipline, but the discipline shows up more in the scaffolding rather than the code.} {The tooling, abstractions, and feedback loops [that keep the codebase coherent] are increasingly important.}**

我们还不知道的是：在完全由 **Agent** 生成的系统中，架构一致性会如何随时间演进。我们仍在探索人类判断力在哪里能发挥最大杠杆，以及如何编码这种判断力让它产生复利。有一点已经清晰：构建软件依然需要纪律，但这种纪律更多体现在脚手架上而非代码本身。让代码库保持一致的工具、抽象层和反馈循环，正变得越来越重要。

解析：
* **coherence** /kəʊˈhɪərəns/：名词，一致性、连贯性
* **discipline** /ˈdɪsɪplɪn/：纪律、规范（不只是"学科"，这里是"严格自律"）
* **shows up** 🔥：体现出来、以……形式出现

---

> *(40)*

**{Our most difficult challenges now center on [designing environments, feedback loops, and control systems (that help agents accomplish our goal: build and maintain complex, reliable software at scale)].} {As agents like Codex take on larger portions of the software lifecycle, these questions will matter even more.} {We hope [that sharing some early lessons helps you reason about where to invest your effort (so you can just build things)].}**

我们目前最难的挑战，集中在如何设计环境、反馈循环和控制系统，帮助 **Agent** 实现目标：大规模构建并维护复杂可靠的软件。随着 **Codex** 这样的 **Agent** 承担软件生命周期中越来越大的部分，这些问题将变得更加重要。我们希望分享这些早期经验，能帮你判断该把精力投向哪里，从而真正地去构建产品。

解析：
* **at scale** 🔥：在大规模条件下（常用短语，表示规模化运行）
* **software lifecycle**：软件生命周期（从需求到开发、测试、部署、维护的完整过程）
* **invest your effort**：投入精力（把有限的人类注意力花在最值得的地方）

---

## 📚 段落小结

这篇文章详细记录了 **OpenAI** 团队用五个月时间、以零手写代码的方式构建内部产品的全过程。核心理念是"人类引导方向，**Agent** 执行"——工程师的角色从写代码转变为设计环境、搭建约束体系、构建反馈循环。文章揭示了使 **Agent** 高效工作的关键：让仓库成为知识的唯一可信来源、用机械规则强制执行架构约束、让 **Agent** 能直接"看到"应用的 **UI**、日志和指标，以及建立"黄金原则"驱动的持续垃圾回收机制来对抗代码漂移。

### 🔥 核心词汇表

| 词汇/短语 | 含义 |
|---------|------|
| **steer** | 掌舵、引导方向 |
| **orders of magnitude** | 数个数量级（10倍、100倍量级）|
| **feedback loop** | 反馈循环 |
| **depth-first** | 深度优先（先深入再扩展）|
| **building blocks** | 构建块、基本模块 |
| **legible** | 可读的（Agent 可理解的）|
| **ephemeral** | 临时的、短暂的 |
| **tractable** | 可处理的、可操作的 |
| **system of record** | 唯一可信来源 |
| **progressive disclosure** | 渐进式披露（按需展示信息）|
| **opinionated** | 有明确立场的 |
| **cadence** | 周期性节奏 |
| **at scale** | 在大规模条件下 |
| **counterproductive** | 适得其反的 |
| **acceptance criteria** | 验收标准 |
| **end-to-end** | 端到端（完整流程）|
| **threshold** | 门槛、临界点 |
| **invariants** | 不变量（始终为真的约束）|
| **ad-hoc** | 临时性的（不系统）|
| **multiplier** | 乘数、放大器 |
| **guardrails** | 护栏（防止越界的约束机制）|
| **compound** | 复利积累、使问题加剧 |
| **cross-cutting concerns** | 横切关注点（贯穿多模块的功能）|
| **meet the bar** | 达标 |
| **scale (v.)** | 规模化（"doesn't scale"）|
